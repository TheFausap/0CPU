.libhdr

; ---- Constant Pool (labels at CONST_BASE) ----
.constbase 1000
ONE:
q47  1.0
C3:
q47 -0.16666666666666666       ; -1/6
C5:
q47  0.008333333333333333      ;  1/120
C7:
q47 -0.0001984126984126984     ; -1/5040

D2:
q47 -0.5                       ; -1/2
D4:
q47  0.041666666666666664      ;  1/24
D6:
q47 -0.001388888888888889      ; -1/720


; ---- Additional constants for tan / atan ----
D3:
q47  0.3333333333333333        ; +1/3
D5_TAN:
q47  0.13333333333333333       ; +2/15
D7_TAN:
q47  0.05396825396825397       ; +17/315

A3:
q47 -0.3333333333333333        ; -1/3
A5:
q47  0.2                       ; +1/5
A7:
q47 -0.14285714285714285       ; -1/7
A9:
q47  0.1111111111111111        ; +1/9
A11:
q47 -0.0909090909090909        ; -1/11


; ---- Utility constants for sign testing & saturated adjustments ----
SIGN:
bits 0x800000000000            ; top bit mask (sign bit in 48-bit two's complement)
MONE:
q47  -1.0                      ; -1.0
PI:
q47 3.141592653589793          ; PI (now representable in Q3.45)
MPI:
q47 -3.141592653589793         ; -PI
TAN_PI_8:
q47  0.4142135623730950        ; tan(pi/8)
PI_4:
q47  0.7853981633974483        ; pi/4
HALF:
q47  0.5                       ; 0.5
ONE_HALF:
q47  1.5                       ; 1.5
INV_6:
q47  0.16666666666666666       ; 1/6
INV_720:
q47  0.001388888888888889      ; 1/720
INT_ONE:
bits 1                         ; Integer 1 for shifts
INT_MONE:
bits 0xFFFFFFFFFFFF            ; Integer -1


; ---- Library-local workspace addresses (absolute in library) ----
; X  = 2000
; X2 = 2001
; TMP= 2002
; R  = 2003
; R2 = 2004
; U  = 2005
; RES= 2006

; -----------------------------------------------------------------------------
; sin(x) via Horner:
;   sin(x) ≈ x * (1 + x^2 * (C3 + x^2 * (C5 + x^2 * C7)))
; Args: r1=x (Q3.45)  Returns: r1  Clobbers: r1,r2,r3
; -----------------------------------------------------------------------------
.libfn sin 0x01
.args 1
.returns r1
.clobbers r1,r2,r3

; Save x in library workspace (NOT scratchpad)
instr STORE_R1 2000              ; LIB[2000] = x

; Compute x^2 into LIB[105]
instr LOAD_R2 2000               ; r2 = LIB[2000] = x
instr LOAD_R3 2000               ; r3 = x
instr MUL                       ; r2 * r3 -> r1:r2 (Q6.90)
instr ROUND                     ; r1 = x^2 (Q3.45)
instr STORE_R1 2001              ; LIB[2001] = x^2

; t = C7
instr LOAD_R1 @C7               ; r1 = C7
instr STORE_R1 2002              ; LIB[2002] = t

; t = C5 + t * x^2
instr LOAD_R2 2001               ; r2 = x^2 (from LIB)
instr LOAD_R3 2002               ; r3 = t (from LIB)
instr MUL
instr ROUND                     ; r1 = t * x^2
instr LOAD_R2 @C5               ; r2 = C5
instr ADD                       ; r1 = C5 + t*x^2
instr STORE_R1 2002              ; LIB[2002] = t

; t = C3 + t * x^2
instr LOAD_R2 2001               ; r2 = x^2
instr LOAD_R3 2002               ; r3 = t
instr MUL
instr ROUND                     ; r1 = t * x^2
instr LOAD_R2 @C3               ; r2 = C3
instr ADD                       ; r1 = C3 + t*x^2
instr STORE_R1 2002              ; LIB[2002] = t

; u = 1 + t * x^2
instr LOAD_R2 2001               ; r2 = x^2
instr LOAD_R3 2002               ; r3 = t
instr MUL
instr ROUND                     ; r1 = t * x^2
instr LOAD_R2 @ONE              ; r2 = 1.0
instr ADD                       ; r1 = 1 + t*x^2
instr STORE_R1 2002              ; LIB[2002] = u

; result = x * u
instr LOAD_R2 2000               ; r2 = x
instr LOAD_R3 2002               ; r3 = u
instr MUL
instr ROUND                     ; r1 = x * u

instr RET
.endl


; -----------------------------------------------------------------------------
; cos(x) via Horner:
;   cos(x) ≈ 1 + x^2 * (D2 + x^2 * (D4 + x^2 * D6))
; Args: r1=x (Q3.45)  Returns: r1  Clobbers: r1,r2,r3
; -----------------------------------------------------------------------------
.libfn cos 0x02
.args 1
.returns r1
.clobbers r1,r2,r3

; Save x in library workspace
instr STORE_R1 2000              ; LIB[2000] = x

; Compute x^2 into LIB[105]
instr LOAD_R2 2000               ; r2 = x
instr LOAD_R3 2000               ; r3 = x
instr MUL
instr ROUND                     ; r1 = x^2
instr STORE_R1 2001              ; LIB[2001] = x^2

; t = D6
instr LOAD_R1 @D6
instr STORE_R1 2002              ; t = D6

; t = D4 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @D4
instr ADD
instr STORE_R1 2002              ; t

; t = D2 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @D2
instr ADD
instr STORE_R1 2002              ; t

; result = 1 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @ONE
instr ADD                       ; r1 = 1 + t*x^2

instr RET
.endl



.libfn tan 0x03
.args 1
.returns r1
.clobbers r1,r2,r3

instr STORE_R1 2000              ; x
instr LOAD_R2 2000
instr LOAD_R3 2000
instr MUL
instr ROUND
instr STORE_R1 2001              ; x^2

instr LOAD_R1 @D7_TAN
instr STORE_R1 2002

instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr LOAD_R2 @D5_TAN
instr ADD
instr STORE_R1 2002

instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr LOAD_R2 @D3
instr ADD
instr STORE_R1 2002

instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr LOAD_R2 @ONE
instr ADD                       ; u
instr STORE_R1 2002

instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; u
instr MUL
instr ROUND

instr RET
.endl




; -----------------------------------------------------------------------------
; atan(x) via Horner:
;   atan(x) ≈ x * (1 + x^2 * (A3 + x^2 * (A5 + x^2 * A7)))
; -----------------------------------------------------------------------------
.libfn atan 0x04
.args 1
.returns r1
.clobbers r1,r2,r3

; Save x (r1) and compute x^2
instr STORE_R1 2000              ; Y = x (reuse Y for "x" here)
; ---- Range Reduction ----
; Check if |x| > TAN_PI_8 (0.414...)
; x is in 2000.
; 1. Get abs(x)
instr LOAD_R1 2000               ; x
instr LOAD_R2 @SIGN
instr AND
instr STORE_R1 2005              ; U = sign bit of x (reuse U/2005)
instr LOAD_R1 2000               ; x
instr SKIP_IF_ZERO               ; if x=0, no reduction
instr JUMP ATAN_CHECK_REDUCE
instr JUMP ATAN_DO_SERIES        ; x=0 -> series(0)=0

ATAN_CHECK_REDUCE:
; Compute |x|
instr LOAD_R1 2005               ; sign bit
instr SKIP_IF_ZERO               ; if positive, skip negate
instr JUMP ATAN_NEGATE_X
instr LOAD_R1 2000               ; x
instr JUMP ATAN_STORE_ABS

ATAN_NEGATE_X:
instr LOAD_R1 2000               ; x
instr NEG

ATAN_STORE_ABS:
instr STORE_R1 2004              ; TMP = |x|

; Check if |x| > TAN_PI_8
; Compute |x| - TAN_PI_8
instr LOAD_R1 @TAN_PI_8
instr NEG
instr STORE_R1 2006              ; TMP = -TAN_PI_8 (use RES/2006)
instr LOAD_R2 2004               ; |x|
instr ADD                       ; |x| - 0.414
instr LOAD_R2 @SIGN
instr AND
instr SKIP_IF_ZERO              ; if result >= 0 (so |x| >= 0.414), skip next
instr JUMP ATAN_DO_SERIES       ; Else (negative) -> No reduction
instr JUMP ATAN_DO_REDUCE       ; Positive -> Reduce

ATAN_DO_REDUCE:
; x' = (|x| - 1) / (|x| + 1)
; bias = PI_4
instr LOAD_R1 @PI_4
instr STORE_R1 2006              ; RES = bias

instr LOAD_R1 2004              ; |x|
instr LOAD_R2 @ONE
instr NEG
instr ADD                       ; |x| - 1
instr STORE_R1 2001              ; X2 = numerator (reuse X2)

instr LOAD_R1 2004              ; |x|
instr LOAD_R2 @ONE
instr ADD                       ; |x| + 1
instr STORE_R1 2004              ; TMP = denominator

instr LOAD_R1 2001              ; numerator
instr LOAD_R2 2004              ; denominator
instr DIV
instr STORE_R1 2000              ; x = x' (update x for series)
instr JUMP ATAN_DO_SERIES_BIASED

ATAN_DO_SERIES:
; bias = 0
instr CLEAR_R1
instr STORE_R1 2006              ; RES = 0

ATAN_DO_SERIES_BIASED:
; x is in 2000 (original or reduced).
; RES (2006) holds bias.
; Proceed with series.

; x^2
instr LOAD_R1 2000               ; x
instr LOAD_R2 2000               ; x
instr MUL
instr ROUND
instr STORE_R1 2001              ; X2 = x^2

; t = A11
instr LOAD_R1 @A11
instr STORE_R1 2002              ; TMP = t

; t = A9 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A9
instr ADD
instr STORE_R1 2002              ; TMP = t

; t = A7 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A7
instr ADD
instr STORE_R1 2002              ; TMP = t

; t = A5 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A5
instr ADD
instr STORE_R1 2002              ; TMP = t

; t = A3 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A3
instr ADD
instr STORE_R1 2002              ; TMP = t

; u = 1 + t * x^2
instr LOAD_R2 2001               ; x^2
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @ONE
instr ADD                       ; r1 = u
instr STORE_R1 2002

; result = x * u
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; u
instr MUL
instr ROUND                     ; r1 = series_result

; Add bias
instr LOAD_R2 2006               ; bias
instr ADD                       ; r1 = series_result + bias

; Apply original sign of x (stored in 2005)
instr STORE_R1 2006              ; Store absolute result

instr LOAD_R1 2005               ; sign bit
instr SKIP_IF_ZERO               ; if positive, done
instr JUMP ATAN_NEGATE_RESULT
instr JUMP ATAN_RET

ATAN_NEGATE_RESULT:
instr LOAD_R1 2006
instr NEG
instr STORE_R1 2006

ATAN_RET:
instr LOAD_R1 2006
instr RET
.endl



; -----------------------------------------------------------------------------
; atan2(y, x): returns angle in radians (Q3.45)
; PB: PB[1]=y -> r1, PB[2]=x -> r2
; -----------------------------------------------------------------------------
.libfn atan2 0x05
.args 2
.returns r1
.clobbers r1,r2,r3

; Pre-store y and x to workspace for later sign/quadrant checks
instr STORE_R1 2000              ; Y = y (from PB in r1)
instr CLEAR_R1
instr ADD                       ; r1 := r1 + r2  (copy x from r2 into r1)
instr STORE_R1 2001              ; X = x

; ---- Special case: x == 0 ----
instr LOAD_R1 2001               ; r1 = x
instr SKIP_IF_NONZERO           ; if x != 0 skip next
instr JUMP ATAN2_X_ZERO         ; else -> handle x==0

; ---- Normal path: x != 0 ----
; r = y / x
instr LOAD_R1 2000               ; y
instr LOAD_R2 2001               ; x
instr DIV                       ; r1 = y/x
instr STORE_R1 2002              ; R = r

; r^2
instr LOAD_R2 2002               ; r
instr LOAD_R3 2002               ; r
instr MUL
instr ROUND
instr STORE_R1 2003              ; R2 = r^2

; ---- Range Reduction ----
; Check if |r| > TAN_PI_8 (0.414...)
; We work with absolute value of r for the check, but transformation depends on sign?
; Identity: atan(x) = sign(x) * atan(|x|)
; Transformation: atan(|x|) = pi/4 + atan( (|x|-1)/(|x|+1) )
; So we can reduce |r| and then apply sign(r) to the result.

; 1. Get abs(r)
instr LOAD_R1 2002               ; r
instr LOAD_R2 @SIGN
instr AND
instr STORE_R1 2005              ; U = sign bit of r
instr LOAD_R1 2002               ; r
instr SKIP_IF_ZERO               ; if r=0, no reduction needed
instr JUMP ATAN2_CHECK_REDUCE
instr JUMP ATAN2_DO_SERIES       ; r=0 -> series(0)=0

ATAN2_CHECK_REDUCE:
; Compute |r|
instr LOAD_R1 2005               ; sign bit
instr SKIP_IF_ZERO               ; if positive (sign=0), skip negate logic
instr JUMP ATAN2_NEGATE_R
instr LOAD_R1 2002               ; r (positive)
instr JUMP ATAN2_STORE_ABS

ATAN2_NEGATE_R:
instr LOAD_R1 2002               ; r
instr NEG

ATAN2_STORE_ABS:
instr STORE_R1 2004              ; TMP = |r|

; Check if |r| > TAN_PI_8
; Compute |r| - TAN_PI_8
instr LOAD_R1 @TAN_PI_8
instr NEG
instr STORE_R1 2006              ; TMP = -TAN_PI_8 (use RES/2006, preserve U/2005)
instr LOAD_R2 2004               ; |r|
instr ADD                       ; -TAN_PI_8 + |r| = |r| - 0.414
instr LOAD_R2 @SIGN
instr AND
instr SKIP_IF_ZERO              ; if result >= 0 (so |r| >= 0.414), skip next
instr JUMP ATAN2_DO_SERIES      ; Else (negative) -> No reduction
instr JUMP ATAN2_DO_REDUCE      ; Positive -> Reduce

ATAN2_DO_REDUCE:
; r' = (|r| - 1) / (|r| + 1)
; bias = PI_4
instr LOAD_R1 @PI_4
instr STORE_R1 2006              ; RES = bias (reuse RES temporarily)

instr LOAD_R1 2004              ; |r|
instr LOAD_R2 @ONE
instr NEG
instr ADD                       ; |r| - 1
instr STORE_R1 2001              ; X2 = numerator (reuse X2)

instr LOAD_R1 2004              ; |r|
instr LOAD_R2 @ONE
instr ADD                       ; |r| + 1
instr STORE_R1 2004              ; TMP = denominator

instr LOAD_R1 2001              ; numerator
instr LOAD_R2 2004              ; denominator
instr DIV
instr STORE_R1 2004              ; TMP = r' (reduced argument)

; Update r and r^2 for series
instr LOAD_R1 2004              ; r'
instr STORE_R1 2002              ; R = r' (store back to R for series)
instr LOAD_R2 2004
instr LOAD_R3 2004
instr MUL
instr ROUND
instr STORE_R1 2003              ; R2 = (r')^2
instr JUMP ATAN2_DO_SERIES_BIASED

ATAN2_DO_SERIES:
; bias = 0
instr CLEAR_R1
instr STORE_R1 2006              ; RES = 0

ATAN2_DO_SERIES_BIASED:
; Now R (2002) is the argument (either r or r'), R2 (2003) is argument^2.
; RES (2006) holds the bias (0 or PI_4).
; We proceed with Horner series on R.

; t = A11
instr LOAD_R1 @A11
instr STORE_R1 2004              ; TMP = t

; t = A9 + t * r^2
instr LOAD_R2 2003               ; r^2
instr LOAD_R3 2004               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A9
instr ADD
instr STORE_R1 2004              ; t

; t = A7 + t * r^2
instr LOAD_R2 2003               ; r^2
instr LOAD_R3 2004               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A7
instr ADD
instr STORE_R1 2004              ; t

; t = A5 + t * r^2
instr LOAD_R2 2003               ; r^2
instr LOAD_R3 2004               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A5
instr ADD
instr STORE_R1 2004              ; t

; t = A3 + t * r^2
instr LOAD_R2 2003               ; r^2
instr LOAD_R3 2004               ; t
instr MUL
instr ROUND
instr LOAD_R2 @A3
instr ADD
instr STORE_R1 2004              ; t

; u = 1 + t * r^2
instr LOAD_R2 2003               ; r^2
instr LOAD_R3 2004               ; t
instr MUL
instr ROUND
instr LOAD_R2 @ONE
instr ADD
instr STORE_R1 2004              ; u

; a = r * u
instr LOAD_R2 2002               ; r (or r')
instr LOAD_R3 2004               ; u
instr MUL
instr ROUND                     ; r1 = series_result

; Add bias (stored in RES)
instr LOAD_R2 2006               ; bias (0 or PI_4)
instr ADD                       ; r1 = series_result + bias

; Apply original sign of r (stored in 2005)
; If original r was negative, result should be negative.
; But wait, we reduced |r|.
; atan(r) = sign(r) * atan(|r|)
; We computed atan(|r|) = bias + series(r').
; So we need to negate if original r was negative.
instr STORE_R1 2006              ; Store absolute result temporarily

instr LOAD_R1 2005               ; sign bit of original r
instr SKIP_IF_ZERO               ; if positive, done
instr JUMP ATAN2_NEGATE_RESULT
instr JUMP ATAN2_STORE_FINAL

ATAN2_NEGATE_RESULT:
instr LOAD_R1 2006
instr NEG
instr STORE_R1 2006
instr JUMP ATAN2_STORE_FINAL

ATAN2_STORE_FINAL:
; Result is in RES (2006).
; Proceed to quadrant check.

; Quadrant adjust when x < 0:
instr LOAD_R1 2001               ; r1 = x
instr LOAD_R2 @SIGN
instr AND                       ; r1 = SIGN if x<0 else 0
instr SKIP_IF_ZERO              ; x >= 0 -> RET
instr JUMP ATAN2_X_NEG          ; else -> y sign decides ±PI

; x >= 0
instr LOAD_R1 2006               ; Restore result
instr RET

ATAN2_X_NEG:
; x < 0: check y sign
instr LOAD_R1 2000               ; r1 = y
instr LOAD_R2 @SIGN
instr AND                       ; r1 = SIGN if y<0 else 0
instr SKIP_IF_ZERO              ; y >= 0 -> add +PI
instr JUMP ATAN2_ADD_MPI        ; else -> add -PI

; Add +PI
instr LOAD_R1 2006               ; Restore result
instr LOAD_R2 @PI
instr ADD
instr RET

ATAN2_ADD_MPI:
; Add -PI
instr LOAD_R1 2006               ; Restore result
instr LOAD_R2 @MPI
instr ADD
instr RET


ATAN2_X_ZERO:
; x == 0:
instr LOAD_R1 2000               ; r1 = y
instr SKIP_IF_ZERO              ; if y == 0 -> next (return 0)
instr JUMP ATAN2_Y_NONZERO      ; else -> ±PI/2

; y == 0 -> 0
instr CLEAR_R1
instr RET

ATAN2_Y_NONZERO:
; y != 0: sign(y) -> ±PI/2
instr LOAD_R2 @SIGN
instr AND                       ; r1 = SIGN if y<0 else 0
instr SKIP_IF_ZERO              ; if non-negative -> +PI/2
instr JUMP ATAN2_RET_MPI2       ; else -> -PI/2

; +PI/2
instr LOAD_R1 @PI
instr LOAD_R2 @ONE              ; 1.0
instr ADD                       ; 1.0 (dummy to set r2=1.0 for shift?) No, just load PI and shift
instr LOAD_R1 @PI
instr CLEAR_R2
instr LOAD_R2 1                 ; shift right 1
instr SHIFT_RIGHT               ; PI/2
instr RET

ATAN2_RET_MPI2:
; -PI/2
instr LOAD_R1 @MPI
instr CLEAR_R2
instr LOAD_R2 1
instr SHIFT_RIGHT               ; -PI/2
instr RET

.endl


; -----------------------------------------------------------------------------
; inv_sqrt(x): returns 1/sqrt(x) (Q3.45)
; x > 0.0625 (approx) to avoid overflow > 4.0
; -----------------------------------------------------------------------------
.libfn inv_sqrt 0x06
.args 1
.returns r1
.clobbers r1,r2,r3

; Store x
instr STORE_R1 2000              ; x

; Initial guess y = 1.0
instr LOAD_R1 @ONE
instr STORE_R1 2001              ; y

; Unrolled loop (5 iterations)
; Iteration 1
instr LOAD_R2 2001               ; y
instr LOAD_R3 2001               ; y
instr MUL
instr ROUND                     ; y^2
instr STORE_R1 2002              ; TMP = y^2
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; y^2
instr MUL
instr ROUND                     ; x * y^2
instr STORE_R1 2002              ; TMP
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND                     ; 0.5 * x * y^2
instr STORE_R1 2002              ; TMP
instr LOAD_R1 2002               ; term
instr NEG                       ; -term
instr LOAD_R2 @ONE_HALF
instr ADD                       ; 1.5 - term
instr STORE_R1 2002              ; factor
instr LOAD_R2 2001               ; y
instr LOAD_R3 2002               ; factor
instr MUL
instr ROUND                     ; y_new
instr STORE_R1 2001              ; update y

; Iteration 2
instr LOAD_R2 2001
instr LOAD_R3 2001
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 2000
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R1 2002
instr NEG
instr LOAD_R2 @ONE_HALF
instr ADD
instr STORE_R1 2002
instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

; Iteration 3
instr LOAD_R2 2001
instr LOAD_R3 2001
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 2000
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R1 2002
instr NEG
instr LOAD_R2 @ONE_HALF
instr ADD
instr STORE_R1 2002
instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

; Iteration 4
instr LOAD_R2 2001
instr LOAD_R3 2001
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 2000
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R1 2002
instr NEG
instr LOAD_R2 @ONE_HALF
instr ADD
instr STORE_R1 2002
instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

; Iteration 5
instr LOAD_R2 2001
instr LOAD_R3 2001
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 2000
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
instr LOAD_R1 2002
instr NEG
instr LOAD_R2 @ONE_HALF
instr ADD
instr STORE_R1 2002
instr LOAD_R2 2001
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

instr LOAD_R1 2001               ; return y
instr RET
.endl


; -----------------------------------------------------------------------------
; sqrt(x): returns sqrt(x) (Q3.45)
; -----------------------------------------------------------------------------
.libfn sqrt 0x07
.args 1
.returns r1
.clobbers r1,r2,r3

; Store x
instr STORE_R1 2000              ; x

; Initial guess y = 1.0
instr LOAD_R1 @ONE
instr STORE_R1 2001              ; y

; Unrolled loop (5 iterations)
; Iteration 1
instr LOAD_R1 2000               ; x
instr LOAD_R2 2001               ; y
instr DIV                       ; x/y
instr STORE_R1 2002              ; TMP = x/y
instr LOAD_R1 2001               ; y
instr LOAD_R2 2002               ; x/y
instr ADD
instr STORE_R1 2002              ; sum
instr LOAD_R2 @HALF
instr LOAD_R3 2002               ; sum
instr MUL
instr ROUND                     ; y_new
instr STORE_R1 2001              ; update y

; Iteration 2
instr LOAD_R1 2000
instr LOAD_R2 2001
instr DIV
instr STORE_R1 2002
instr LOAD_R1 2001
instr LOAD_R2 2002
instr ADD
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

; Iteration 3
instr LOAD_R1 2000
instr LOAD_R2 2001
instr DIV
instr STORE_R1 2002
instr LOAD_R1 2001
instr LOAD_R2 2002
instr ADD
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

; Iteration 4
instr LOAD_R1 2000
instr LOAD_R2 2001
instr DIV
instr STORE_R1 2002
instr LOAD_R1 2001
instr LOAD_R2 2002
instr ADD
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

; Iteration 5
instr LOAD_R1 2000
instr LOAD_R2 2001
instr DIV
instr STORE_R1 2002
instr LOAD_R1 2001
instr LOAD_R2 2002
instr ADD
instr STORE_R1 2002
instr LOAD_R2 @HALF
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2001

instr LOAD_R1 2001               ; return y
instr RET
.endl


; -----------------------------------------------------------------------------
; exp(x): returns e^x (Q3.45)
; Range reduction: x = x / 2^k until |x| < 0.5
; Taylor series: 1 + x + x^2/2! + ... + x^6/6!
; Reconstruction: result = result^(2^k)
; -----------------------------------------------------------------------------
.libfn exp 0x08
.args 1
.returns r1
.clobbers r1,r2,r3

; Store x
instr STORE_R1 2000              ; x

; Check sign and make positive
instr LOAD_R2 @SIGN
instr AND
instr STORE_R1 2006              ; initial sign
instr SKIP_IF_ZERO
instr JUMP EXP_MAKE_POS
instr JUMP EXP_INIT_K

EXP_MAKE_POS:
instr LOAD_R1 2000
instr NEG
instr STORE_R1 2000              ; x = |x|
instr JUMP EXP_INIT_K

EXP_INIT_K:
; Initialize k = 0
instr CLEAR_R1
instr STORE_R1 2005              ; k

; Range reduction loop
EXP_REDUCE_LOOP:
; Check if x < 0.5 (x is positive)
instr LOAD_R1 2000               ; x
instr LOAD_R2 @D2               ; -0.5
instr ADD                       ; x - 0.5
instr LOAD_R2 @SIGN
instr AND
instr SKIP_IF_ZERO              ; if result >= 0 (so x >= 0.5), skip to reduce
instr JUMP EXP_DO_SERIES        ; Else (x < 0.5), proceed to series
instr JUMP EXP_DO_REDUCE        ; Reduce (x >= 0.5)

EXP_DO_REDUCE:
; x = x / 2
instr LOAD_R1 2000
instr CLEAR_R2
instr SHIFT_RIGHT 1
instr STORE_R1 2000              ; x
; k++
instr LOAD_R1 2005
instr LOAD_R2 @INT_ONE
instr ADD
instr STORE_R1 2005
instr JUMP EXP_REDUCE_LOOP

EXP_DO_SERIES:
; Horner's method for 1 + x + x^2/2! + ... + x^6/6!
; t = 1/720
instr LOAD_R1 @INV_720
instr STORE_R1 2002              ; t

; t = 1/120 + t*x
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @C5               ; 1/120
instr ADD
instr STORE_R1 2002

; t = 1/24 + t*x
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @D4               ; 1/24
instr ADD
instr STORE_R1 2002

; t = 1/6 + t*x
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @INV_6            ; 1/6
instr ADD
instr STORE_R1 2002

; t = 0.5 + t*x
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @HALF             ; 0.5
instr ADD
instr STORE_R1 2002

; t = 1 + t*x
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @ONE
instr ADD
instr STORE_R1 2002              ; t

; result = 1 + x*t
instr LOAD_R2 2000               ; x
instr LOAD_R3 2002               ; t
instr MUL
instr ROUND
instr LOAD_R2 @ONE
instr ADD
instr STORE_R1 2002              ; result

; Reconstruction loop
EXP_RECONSTRUCT:
instr LOAD_R1 2005               ; k
instr SKIP_IF_ZERO
instr JUMP EXP_SQUARE
instr JUMP EXP_CHECK_INVERT

EXP_SQUARE:
; result = result * result
instr LOAD_R2 2002
instr LOAD_R3 2002
instr MUL
instr ROUND
instr STORE_R1 2002
; k--
instr LOAD_R1 2005
instr LOAD_R2 @INT_MONE
instr ADD
instr STORE_R1 2005
instr JUMP EXP_RECONSTRUCT

EXP_CHECK_INVERT:
instr LOAD_R1 2006               ; initial sign
instr SKIP_IF_ZERO
instr JUMP EXP_INVERT
instr JUMP EXP_RET

EXP_INVERT:
instr LOAD_R2 2002               ; result
instr LOAD_R1 @ONE
instr DIV
instr STORE_R1 2002
instr JUMP EXP_RET

EXP_RET:
instr LOAD_R1 2002
instr RET
.endl
